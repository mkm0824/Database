--그룹함수 --행에대한 기초 통계값
--SUM, AVG, MAX, MIN, COUNT - 전부 NULL이 아닌 데이터에 대해서 통계를 구합니다.

SELECT SUM(SALARY), AVG(SALARY), MAX(SALARY), MIN(SALARY), COUNT(SALARY) FROM EMPLOYEES;
--MIN, MAX 날짜, 문자열에도 적용이됩니다
SELECT MIN(HIRE_DATE), MAX(HIRE_DATE), MIN(FIRST_NAME), MAX(FIRST_NAME) FROM EMPLOYEES;
--COUNT함수는 2가지 사용방법이 있음
SELECT COUNT(COMMISSION_PCT) FROM EMPLOYEES; --35 NULL이 아닌 데이터에 대해서 집계
SELECT COUNT(*) FROM EMPLOYEES; -- 107, 전체행수(NULL포함)
--주의할점: 그룹함수는 일반컬럼과 동시에 사용이 불가능
SELECT FIRST_NAME, AVG(SALARY) FROM EMPLOYEES;-- X 

-- 그룹함수 뒤에 OVER() 를 붙이면 전체행이 출력이되고, 그룹함수 사용이 가능함
SELECT FIRST_NAME, AVG(SALARY) OVER(), COUNT(*) OVER() FROM EMPLOYEES;

-----------------------------------------------------------------------------------------------------
--GROUP BY절 - 컬럼기준으로 그룹핑
SELECT DEPARTMENT_ID FROM EMPLOYEES GROUP BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, SUM(SALARY), AVG(SALARY), MIN(SALARY0, MAX(SALARY), COUNT(*)
FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
--주위할점 - GROUP BY에 지정 되지 않은 컬럼은 SELECT절에 사용할 수 없음
SELECT DEPARTMENT_ID,
           DIRST_NAME -- X
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID; 
--2개이상의 그룹화
SELECT DEPARTMENT_ID, JOB_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;
--COUNT(*) OVER() 총 행의 수를 출력할 수도 있음.
SELECT DEPARTMENT_ID, JOB_ID, COUNT(*), COUNT (*) OVER() AS 전체행수 
FROM EMPLOYEES
GROUP DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;
--WHERE 절에 그룹의 조건을 넣는것이 아닙니다
SELECT DEPARTMENT_ID, SUM(SALARY)
FROM EMPLOYEES
WHERE SUM(SALARY) >= 50000 -- GROUP BY조건을쓰는 곳은 HAVING이라고있음
GROUP BY DEPARTMENT_ID;
----------------------------------------------------------------------------------------------
--HAVING - 그룹BY의 조건
--WHERE - 일반행 조건
SELECT DEPARTMENT_ID, AVG(SALARY), COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) >= 5000 AND COUNT(*) >= 1;
--각 부서별 샐러리들의 급여 평균
SELECT JOB_ID, AVG(SALARY)
FROM EMPLOYEES
WHERE JOB_ID LIKE 'SA%'
GROUP BY JOB_ID
HAVING AVG(SALARY) >= 10000
ORDER BY AVG(SALARY) DESC;

----------------------------------------------------------
--시험 대비
--ROLL UP - GROUP BY와 함꼐 사용되고, 상위그룹의  소게를 구하니다
SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID);
--
SELECT DEPARTMENT_ID, JOB_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP (DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID, JOB_ID;
-- CUBE - 롤업에 의해서 구해진 값 + 서브그룹의 통계가 추가됨
SELECT DEPARTMENT_ID, JOB_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY CUBE(DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID, JOB_ID;

--GROUPING() - 그룹절로 만들어진 경우에는 0을 반환, 롤업OR큐브로 만들어진 행인 경우에는 1을 반환
SELECT DECODE( GROUPING(DEPARTMENT_ID), 1, '총계', DEPARTMENT_ID)  AS DEPARTMENT_ID,
           DECODE( GROUPING(JOB_ID), 1, '소계', JOB_ID) AS JOB_ID
           --,JOB_ID
           ,AVG(SALARY)
           ,GROUPING(DEPARTMENT_ID)
           ,GROUPING(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID, JOB_ID;


